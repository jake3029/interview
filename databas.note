sql优化：
	主要目的：
		1、减少IO次数
		2、降低CPU计算
	主要内容：
		1、避免使用select *
		2、使用where 代替having (having在查询结果出来之后就行过滤)
		3、尽量减少like使用，会走全表扫描
		4、尽量使用join，避免使用子查询
		5、使用EXISTS代替IN、使用NOT EXISTS代替NO IN （后者会走全表扫描）
		6、对于update不频繁的数据开启查询缓存（MySql8，没有查询缓存，不适用）
		7、尽量使用定长字段
		8、尽量避免在where中进行null判断、表达式操作、函数操作和！= > < (会放弃索引)
		9、常用的查询字段建立索引
		10、尽量使用数据类型而非字符类型
union和union all 的区别？
    union：表连接后会去掉重复的记录，内部必须有相同的列，同时进行默认的排序
    unionall：包括重复行，并不排序
如何使用执行计划？
    实例：EXPLAIN SELECT * FROM SC sc LEFT JOIN Student s ON sc.`SId` = s.`SId` WHERE s.`Sname` = '张三'
如何对千万级大表的进行优化？
	1、优化sql和索引（根据业务优化）
	2、使用redis（2/8原则）
	3、读写分离
	4、分区表——需要针对重写sql
	5、垂直拆分
	6、水平拆分
	7、引擎更换为MyISAM
数据库事务必须满足哪几个条件？
    主要有：原子性、一致性、隔离性、持久性
    原子性：一个事务的多个操作不可分割，要么成功，要么失败，没有中间状态
    一致性：事务执行后，数据不会被破坏
    隔离性：事务是互相隔离的，操作不会被对方干扰
        导致的问题：
            3个读问题：脏读、不可重复读、幻读
            2个数据更新问题：
                A事务回滚后，把已经提交的B事务的数据覆盖了
                A事务覆盖B事务已经提交的数据，造成B事务的所有数据丢失
         隔离级别：
            读未提交：可以读取已修改但未提交的数据
            可重复读：
            不可重复读：
            串行化：
    持久性：事务提交完成后，即使数据库奔溃，数据也不会丢失


