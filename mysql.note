7、优化
	MySql优化主要从4个方面
	1、查询语句的优化
        1、减少IO次数
        2、降低CPU计算
        主要内容：
            1、避免使用select *
            2、使用where 代替having (having在查询结果出来之后进行过滤)
            3、尽量减少like使用，会走全表扫描
            4、尽量使用join，避免使用子查询
            5、使用EXISTS代替IN、使用NOT EXISTS代替NO IN （后者会走全表扫描）
            6、对于update不频繁的数据开启查询缓存（MySql8，没有查询缓存，不适用）
            7、尽量使用定长字段
            8、尽量避免在where中进行null判断、表达式操作、函数操作和！= > < (会放弃索引)
            9、常用的查询字段建立索引
            10、尽量使用数据类型而非字符类型
            11、 
	2、优化数据库结构
		1、将字段很多的表按照表中字段的使用频率分解成多个表
		2、增加中间表（将原来联合查询的结果放到中间表中）。
			缺点：数据的实时性得不到保障
		3、增加冗余字段（以空间换时间）
		4、优化数据插入的速度
			1、禁用索引
			2、禁用唯一性约束
			3、使用批量插入
			4、尽量使用 load data infile（数据导入）
				禁用自动提交、禁用外键
		5、分析表、检查表、优化表
			analyze table user;
			check table user ;
			optimize table user;
	3、优化mysql服务器
		主要是硬件的优化和对mysql服务的参数进行优化
		1、硬件优化
			加大cpu
			加大磁盘，使用固态硬盘
			加大内存
		2、MySql服务器参数
			1、使用查询缓存区
			2、。。。。。
	4、操作系统优化
如何对千万级大表的进行优化？
	1、优化sql和索引（根据业务优化）
	2、使用redis（2/8原则）
	3、读写分离
	4、分区表——需要针对重写sql
	5、垂直拆分
	6、水平拆分
	7、引擎更换为MyISAM
1、mysql5.5 5.6 5.7.8有什么变化
	5.5之后
		支持事务、行级锁、表与索引存储到
	5.6之后
	     	支持表空间在线迁移、
        5.7之后
		1、支持对json的支持
	5.8之后
		去掉了查询缓存
2、MySql底层什么原理？
	B+树，叶子节点上增加了指向下一个节点的指针
3、普通索引、主键索引、唯一索引和组合索引有什么区别？
	1、普通索引，最基本的索引，没有任何限制
	2、主键索引，特殊的唯一索引，不容许有空值
	3、唯一索引，允许有空值
	4、全局索引，MyIsam引擎才能用
	5、组合索引，遵循最左前缀的原则
4、逻辑架构
	MySql逻辑上分为：service和存储引擎
	    连接器
	      功能：建立连接、获取权限、维持和管理连接
	      种类
	        长链接导致占用内存多怎么办？
	    查询缓存
	      大多数情况下我会建议你不要使用查询缓存，为什么呢？
	      最佳实践
	      注意
	        需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。
	    分析器
	      词法分析
	      语法分析
	    优化器
	    执行器
  存储引擎
    作用
      负责数据的存储和提取
    架构模式
      插件式
    类型
      MyISAM
      innodb
        5.5.5版本后默认
      memory
6、事务
  ACID
    原子性
    一致性
    隔离性
      解决的问题
        脏读
        不可重复读
        幻读
      隔离级别
        读未提交
          一个事务还没提交时，它做的变更就能被别的事务看到。
        读提交
          一个事务提交之后，它做的变更才会被其他事务看到。
          Oracle 默认隔离级别“读提交”
        可重复读
          一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
          mysql默认可重复读
            修改为读提交配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。
          使用场景
        串行化
          对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
      隔离级别的实现
        回滚段
        review
        避免长事务
    持久性
  什么是事务？
  	MySql原生数据库引擎MyISAM不支持事务
  事务的启动方式
    	显式启动事务语句， begin 或 start transaction。
    	set autocommit=0，这个命令会将这个线程的自动提交关掉。

数据库事务必须满足哪几个条件？
    主要有：原子性、一致性、隔离性、持久性
    原子性：一个事务的多个操作不可分割，要么成功，要么失败，没有中间状态
    一致性：事务执行后，数据不会被破坏
    隔离性：事务是互相隔离的，操作不会被对方干扰
        导致的问题：
            3个读问题：脏读、不可重复读、幻读
            2个数据更新问题：
                A事务回滚后，把已经提交的B事务的数据覆盖了
                A事务覆盖B事务已经提交的数据，造成B事务的所有数据丢失
         隔离级别：
            读未提交：可以读取已修改但未提交的数据
            可重复读：
            不可重复读：
            串行化：
    持久性：事务提交完成后，即使数据库奔溃，数据也不会丢失
union和union all 的区别？
    union：表连接后会去掉重复的记录，内部必须有相同的列，同时进行默认的排序
    unionall：包括重复行，并不排序
5、日志系统
    redo log
        innodb独有
    binlog
      mysql一直有
      service层的
      追加写
如何使用执行计划？
    实例：EXPLAIN SELECT * FROM SC sc LEFT JOIN Student s ON sc.`SId` = s.`SId` WHERE s.`Sname` = '张三'
drop， delete truncate的区别？
  drop：数据和结构一起删除
  delete：只删除数据
  truncate：删除不留日志