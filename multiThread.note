5、线程有几种状态？
	创建（new Thread ,新建了一个线程）
	就绪（调用了start方法，但是还没有获取到cpu使用权）
	运行(获得了cpu时间片)
	阻塞（由于各种原因，放弃了cpu控制权）
	死亡（线程的run方法执行结束 main方法执行结束，或者遇到异常导致run方法执行结束，死亡的线程不能在复生）
6、并发框架
    线程池Executor
      什么是两级调度模型
        Executor负责控制上层的调度
        下层由操作系统内核控制
      组成
        任务
          实现Runnable接口后者callable接口的类
        任务执行器
        Future 异步计算的结果
          Executor可以把一个Runnable封装成一个callable
      工作队列
        LinkedBlockingQueue
        SynchronousQueue
        ArrayBlockingQueue
        PriorityBlockingQueue
    并发工具
        Semaphore信号量
            实现：一个计数器、一个等待队列、三个原子性方法（init、down、up）
            用途：
                1、互斥锁
                
            说明：java中主要使用管程模型，不太使用信号量模型
            缺点：一旦程序出现问题（比如异常关闭）就有可能形成永久占用

        ReadLWriteock读写锁：ReentrantReadWriteLock
        	表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁
            适用场景：
            	读多写少
                可以实现缓存：
            基本原则：
                1、允许多个线程同时读共享变量
                2、只允许一个线程写共享变量
                3、如果一个线程正在写操作，则禁止多个线程共享变量
            性能：
                性能优于互斥锁，因为他可以允许同时多个线程读共享变量
            特点：
                1、ReadWriteLock只能降级，不支持锁的升级，
                2、读锁和写锁都实现了java.util.concurent.locks.Lock接口，写锁支持变量，读锁不支持变量
                3、多个线程读的时候，写操作会被阻塞
                4、是可重入的
        	进入条件：
	        	线程进入读锁的前提条件：
					没有其他线程的写锁，
					没有写请求或者有写请求，但调用线程和持有锁的线程是同一个。
				线程进入写锁的前提条件：
					没有其他线程的读锁
					没有其他线程的写锁
        StempedLock改进的读写锁
            jdk1.8 引入
            模式：
                写锁（和WriteReadLock写锁是差不多的）
                悲观读锁
                乐观读（是无锁的），使用版本号实现
            特点：
                1、写锁和悲观读锁会返回一个stamp，然后解锁的时候，需要传入这个stamp
                2、乐观读，允许一个线程获取写锁，也就是说不是所有的写操作都被阻塞
                3、不支持可重入
                4、使用过程中不要调用Interrupt操作，如果必须使用，可以用readLockInterruptibly和、writeLockInterruptibly
                5、支持锁的升级和降级
            性能：
                1、读多写少的简单的应用场景，性能比ReadWriteLock好
                2、
        CountDownLatch计数器闭锁
            1、允许一个或多个线程等待其他线程完成操作哦
            2、一个计数器、一个队列、三个方法（init、down、up）
            3、可以实现thread中的join功能
            4、计数器只能使用一次
            5、
        CyclicBarrier线程互相等待
            1、可以让一组线程相互等待，当每个线程都准备好之后，所有线程才继续执行的工具类
            2、可以使用reset方法重置，处理更为复杂的方法
            3、

1、什么是多线程？
    实现程序中多个线程并发执行的技术，使程序在同一时间使用cpu多个计算单元
2、为什么要使用多线程？
    单线程不能充分利用多核cpu
3、如何实现多线程？
    继承Thread类
    实现Runnable接口
    实现callable接口
    直接利用线程池创建线程
4、线程间如何通讯？
    wait
    notify
    nofityall
    join
    Interrupted
 5、锁
    什么是乐观锁和悲观锁
        乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将CAS算法这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
        悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。
    锁有几种状态？
        无锁
        偏向锁
        轻量级锁
        重量级锁
    互斥锁
        同一时刻只有一个线程执行
        synchronize是一个互斥锁
    死锁
        产生死锁的条件
            互斥条件：一个资源每次只能被一个进程使用。
            请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
            不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
            循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
         如何预防死锁
            1、破坏占用且等待条件
            2、破坏不可抢占
            3、破坏循环等待条件
千万级秒杀功能的设计？
	1、页面使用cdn缓存
	2、dns负载均衡，将流程分发到不同的
		dns还可以做什么：故障转移，按地区解析
	3、一堆nginx
	4、后台使用内存级别的操作（redis）
		队列等
多线程使用场景
	1、解析excel
		使用CyclicBarrier
		对账

